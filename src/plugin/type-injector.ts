import path from "path";
import fs from "fs/promises";
import { Project } from "ts-morph";

const DEBUG = process.env.DEBUG_OPENAPI === "true";
const PATCH_MARKER = "// AUTO-GENERATED by sveltekit-auto-openapi";

function debug(...args: any[]) {
  if (DEBUG) console.log("[TypeInjector]", ...args);
}

export interface InjectionResult {
  success: boolean;
  typesPath?: string;
  error?: string;
}

interface AnalysisResult {
  hasConfig: boolean;
  methods: string[];
}

/**
 * Analyzes a +server.ts file to detect _config export and HTTP method exports
 * Uses ts-morph for AST parsing (already a dependency)
 */
export async function analyzeServerFile(
  serverPath: string,
  content?: string
): Promise<AnalysisResult> {
  const project = new Project({ useInMemoryFileSystem: true });
  const code = content || (await fs.readFile(serverPath, "utf-8"));
  const sourceFile = project.createSourceFile("temp.ts", code);

  const exportedDecls = sourceFile.getExportedDeclarations();
  const hasConfig = exportedDecls.has("_config");

  const VALID_METHODS = ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"];
  const methods: string[] = [];

  for (const [name] of exportedDecls) {
    if (VALID_METHODS.includes(name)) {
      methods.push(name);
    }
  }

  return { hasConfig, methods };
}

/**
 * Maps +server.ts path to corresponding $types.d.ts path
 * Example: src/routes/api/users/+server.ts
 *       → .svelte-kit/types/src/routes/api/users/$types.d.ts
 */
function resolveTypesPath(serverPath: string, root: string): string {
  const relativePath = path.relative(path.join(root, "src"), serverPath);
  const routeDir = path.dirname(relativePath);
  return path.join(
    root,
    ".svelte-kit",
    "types",
    "src",
    routeDir,
    "$types.d.ts"
  );
}

/**
 * Reverse mapping: $types.d.ts → +server.ts
 */
export function typesPathToServerPath(typesPath: string, root: string): string {
  const typesRoot = path.join(root, ".svelte-kit/types/src");
  const relativePath = path.relative(typesRoot, path.dirname(typesPath));
  return path.join(root, "src", relativePath, "+server.ts");
}

/**
 * Generates TypeScript augmentation code for the given HTTP methods
 */
export function generateAugmentation(methods: string[]): string {
  const methodUnions = methods
    .map((m) => `  | InjectedHelpers<typeof _config, '${m}'>`)
    .join("\n");

  return `
${PATCH_MARKER}
// Do not edit manually - changes will be overwritten
import type { _config } from './+server';
import type { InjectedHelpers } from 'sveltekit-auto-openapi/types';

type AugmentedRequestEvent = Kit.RequestEvent<RouteParams, RouteId> & (
${methodUnions}
);

export type RequestEvent = AugmentedRequestEvent;
export type RequestHandler = (event: AugmentedRequestEvent) => Response | Promise<Response>;
`.trim();
}

/**
 * Extracts methods from an existing patch
 */
function extractMethodsFromPatch(content: string): string[] {
  const matches = content.match(/InjectedHelpers<typeof _config, '(\w+)'>/g);
  if (!matches) return [];

  return matches
    .map((m) => {
      const methodMatch = m.match(/'(\w+)'/);
      return methodMatch ? methodMatch[1] : "";
    })
    .filter((m): m is string => Boolean(m));
}

/**
 * Strips existing patch from content
 */
function stripPatch(content: string): string {
  const markerIndex = content.indexOf(PATCH_MARKER);
  if (markerIndex === -1) return content;
  return content.substring(0, markerIndex).trimEnd();
}

/**
 * Compares two arrays for equality
 */
function arraysEqual(a: string[], b: string[]): boolean {
  return a.length === b.length && a.every((v, i) => v === b[i]);
}

/**
 * Applies or updates the type patch in $types.d.ts
 * Handles deduplication - only writes if content actually changed
 */
async function applyPatch(
  typesPath: string,
  augmentation: string,
  methods: string[]
): Promise<void> {
  let content = await fs.readFile(typesPath, "utf-8");

  // Check if already patched
  if (content.includes(PATCH_MARKER)) {
    const currentMethods = extractMethodsFromPatch(content);

    if (arraysEqual(currentMethods.sort(), methods.sort())) {
      debug(`Patch up-to-date for ${path.basename(path.dirname(typesPath))}`);
      return; // No change needed
    }

    // Remove old patch before applying new one
    content = stripPatch(content);
    debug(`Updating patch for ${path.basename(path.dirname(typesPath))}`);
  }

  // Remove original SvelteKit exports that we're going to override
  // This prevents duplicate export errors
  content = content.replace(
    /export type RequestHandler = .*?;\nexport type RequestEvent = .*?;/,
    ""
  );

  // Append new patch
  const newContent = `${content.trimEnd()}\n\n${augmentation}\n`;
  await fs.writeFile(typesPath, newContent, "utf-8");
}

/**
 * Checks if a file exists
 */
async function fileExists(filePath: string): Promise<boolean> {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}

/**
 * Main function: Injects types for a single route
 * Can be called with file content (HMR) or without (will read from disk)
 */
export async function injectTypesForRoute(
  serverPath: string,
  root: string,
  content?: string
): Promise<InjectionResult> {
  try {
    // 1. Analyze +server.ts for _config and methods
    const { hasConfig, methods } = await analyzeServerFile(serverPath, content);

    if (!hasConfig || methods.length === 0) {
      debug(
        `Skipping ${path.basename(path.dirname(serverPath))}: no config or methods`
      );
      return { success: true }; // Nothing to inject
    }

    // 2. Locate corresponding $types.d.ts
    const typesPath = resolveTypesPath(serverPath, root);

    if (!(await fileExists(typesPath))) {
      debug(`Types not ready for ${path.basename(path.dirname(serverPath))}`);
      return { success: false, error: "Types file not generated yet" };
    }

    // 3. Generate augmentation code
    const augmentation = generateAugmentation(methods);

    // 4. Apply patch to $types.d.ts
    await applyPatch(typesPath, augmentation, methods);

    debug(`✓ Injected types for ${path.basename(path.dirname(serverPath))}`);
    return { success: true, typesPath };
  } catch (err) {
    console.error("[TypeInjector] Failed to inject types:", err);
    return { success: false, error: String(err) };
  }
}

interface PendingInjection {
  serverPath: string;
  methods: string[];
  attempts: number;
}

/**
 * Queue for routes that need type injection but $types.d.ts doesn't exist yet
 */
class InjectionQueue {
  private queue: Map<string, PendingInjection> = new Map();
  private maxAttempts = 5;

  add(serverPath: string, methods: string[]): void {
    this.queue.set(serverPath, { serverPath, methods, attempts: 0 });
    debug(
      `Queued ${path.basename(path.dirname(serverPath))} for type injection`
    );
  }

  async processPending(root: string): Promise<void> {
    if (this.queue.size === 0) return;

    debug(`Processing ${this.queue.size} pending injections`);
    const toRemove: string[] = [];

    for (const [serverPath, pending] of this.queue) {
      pending.attempts++;
      const result = await injectTypesForRoute(serverPath, root);

      if (result.success) {
        toRemove.push(serverPath);
      } else if (pending.attempts >= this.maxAttempts) {
        console.warn(
          `[TypeInjector] Gave up on ${serverPath} after ${this.maxAttempts} attempts`
        );
        toRemove.push(serverPath);
      }
    }

    toRemove.forEach((path) => this.queue.delete(path));
  }

  clear(): void {
    this.queue.clear();
  }
}

export const injectionQueue = new InjectionQueue();
