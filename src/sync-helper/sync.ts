import { Project } from "ts-morph";
import { glob } from "glob";
import path from "path";
import fs from "fs";

export async function _syncAllTypes() {
  try {
    // Check if .svelte-kit directory exists
    if (!fs.existsSync(".svelte-kit")) {
      console.warn(
        "[sveltekit-auto-openapi] .svelte-kit directory not found. Skipping type sync."
      );
      return;
    }

    // Find all +server.ts files with _config
    const serverFiles = await glob("src/routes/**/+server.ts", {
      ignore: ["**/node_modules/**", "**/.svelte-kit/**"],
    });

    for (const serverFile of serverFiles) {
      try {
        // Dynamic import to check for _config export
        const module = await import(path.resolve(process.cwd(), serverFile));

        if (!module._config?.openapiOverride) continue;

        // Extract HTTP methods from _config
        const methods = Object.keys(module._config.openapiOverride || {});
        if (methods.length === 0) continue;

        // Find corresponding $types.d.ts
        const routePath = serverFile
          .replace("src/routes/", "")
          .replace("/+server.ts", "");

        const typesPath = `.svelte-kit/types/src/routes/${
          routePath ? routePath + "/" : ""
        }$types.d.ts`;

        // Check if types file exists
        if (!fs.existsSync(typesPath)) {
          console.warn(
            `[sveltekit-auto-openapi] Types file not found: ${typesPath}`
          );
          continue;
        }

        // Modify the types file
        await modifyTypesFile(typesPath, methods);
      } catch (error) {
        console.error(
          `[sveltekit-auto-openapi] Error processing ${serverFile}:`,
          error
        );
        // Continue with other files
      }
    }
  } catch (error) {
    console.error("[sveltekit-auto-openapi] Error in _syncAllTypes:", error);
  }
}

export async function _syncFileTypes(filePath: string) {
  try {
    // Only process +server.ts files
    if (!filePath.endsWith("+server.ts")) return;

    // Check if .svelte-kit directory exists
    if (!fs.existsSync(".svelte-kit")) {
      console.warn(
        "[sveltekit-auto-openapi] .svelte-kit directory not found. Skipping type sync."
      );
      return;
    }

    // Normalize file path
    const normalizedPath = filePath.replace(/\\/g, "/");

    // Extract route path from file path
    let routePath = "";
    if (normalizedPath.includes("src/routes/")) {
      const parts = normalizedPath.split("src/routes/");
      routePath = (parts[1] ?? "").replace("/+server.ts", "");
    } else {
      console.warn(`[sveltekit-auto-openapi] Invalid path format: ${filePath}`);
      return;
    }

    // Try to import the file to check for _config
    try {
      const module = await import(path.resolve(process.cwd(), filePath));

      if (!module._config?.openapiOverride) {
        // File doesn't have _config, restore original types if needed
        await restoreOriginalTypes(routePath);
        return;
      }

      // Extract HTTP methods from _config
      const methods = Object.keys(module._config.openapiOverride || {});
      if (methods.length === 0) {
        await restoreOriginalTypes(routePath);
        return;
      }

      // Find corresponding $types.d.ts
      const typesPath = `.svelte-kit/types/src/routes/${
        routePath ? routePath + "/" : ""
      }$types.d.ts`;

      // Check if types file exists
      if (!fs.existsSync(typesPath)) {
        console.warn(
          `[sveltekit-auto-openapi] Types file not found: ${typesPath}`
        );
        return;
      }

      // Modify the types file
      await modifyTypesFile(typesPath, methods);
    } catch (error) {
      console.error(
        `[sveltekit-auto-openapi] Error processing ${filePath}:`,
        error
      );
    }
  } catch (error) {
    console.error("[sveltekit-auto-openapi] Error in _syncFileTypes:", error);
  }
}

async function modifyTypesFile(typesPath: string, methods: string[]) {
  try {
    const project = new Project({
      skipAddingFilesFromTsConfig: true,
    });

    const sourceFile = project.addSourceFileAtPath(typesPath);

    // Check if already modified (look for AUTO-GENERATED comment)
    const statements = sourceFile.getStatements();
    let hasAutoGenerated = false;
    let autoGenStartIndex = -1;
    let autoGenEndIndex = -1;

    for (let i = 0; i < statements.length; i++) {
      const stmt = statements[i];
      if (!stmt) continue;
      const text = stmt.getText();
      if (text.includes("AUTO-GENERATED by sveltekit-auto-openapi")) {
        hasAutoGenerated = true;
        autoGenStartIndex = i;
        // Find the end of auto-generated section (before export type RequestEvent)
        for (let j = i; j < statements.length; j++) {
          const innerStmt = statements[j];
          if (
            innerStmt &&
            innerStmt.getText().includes("export type RequestEvent")
          ) {
            autoGenEndIndex = j - 1;
            break;
          }
        }
        break;
      }
    }

    // Remove old injected code if exists
    if (hasAutoGenerated && autoGenStartIndex >= 0 && autoGenEndIndex >= 0) {
      const toRemove = statements.slice(autoGenStartIndex, autoGenEndIndex + 1);
      toRemove.forEach((s) => s.remove());
    }

    // Find insertion point (after RouteId declaration)
    const updatedStatements = sourceFile.getStatements();
    let insertIndex = -1;

    for (let i = 0; i < updatedStatements.length; i++) {
      const stmt = updatedStatements[i];
      if (!stmt) continue;
      const text = stmt.getText();
      if (text.includes("type RouteId")) {
        insertIndex = i + 1;
        break;
      }
    }

    if (insertIndex === -1) {
      console.warn(
        `[sveltekit-auto-openapi] Could not find insertion point in ${typesPath}`
      );
      return;
    }

    // Add comment and imports
    sourceFile.insertStatements(insertIndex, [
      "",
      "// AUTO-GENERATED by sveltekit-auto-openapi",
      "// Do not edit manually - changes will be overwritten",
      "import type { _config } from './+server';",
      "import type { InjectedHelpers } from 'sveltekit-auto-openapi/types';",
      "",
    ]);

    // Create union type for all methods
    const methodUnion = methods
      .map((m) => `  | InjectedHelpers<typeof _config, '${m}'>`)
      .join("\n");

    sourceFile.insertStatements(insertIndex + 6, [
      `type AugmentedRequestEvent = Kit.RequestEvent<RouteParams, RouteId> & (`,
      methodUnion,
      `);`,
      "",
    ]);

    // Remove old RequestEvent and RequestHandler exports
    const exports = sourceFile.getExportedDeclarations();

    const requestEventExport = exports.get("RequestEvent");
    if (requestEventExport) {
      requestEventExport.forEach((d) => {
        if ("remove" in d && typeof d.remove === "function") {
          d.remove();
        }
      });
    }

    const requestHandlerExport = exports.get("RequestHandler");
    if (requestHandlerExport) {
      requestHandlerExport.forEach((d) => {
        if ("remove" in d && typeof d.remove === "function") {
          d.remove();
        }
      });
    }

    // Add new exports at the end
    sourceFile.addStatements([
      "export type RequestEvent = AugmentedRequestEvent;",
      "export type RequestHandler = (event: AugmentedRequestEvent) => Response | Promise<Response>;",
    ]);

    await sourceFile.save();
  } catch (error) {
    console.error(
      `[sveltekit-auto-openapi] Error modifying ${typesPath}:`,
      error
    );
  }
}

async function restoreOriginalTypes(routePath: string) {
  try {
    const typesPath = `.svelte-kit/types/src/routes/${
      routePath ? routePath + "/" : ""
    }$types.d.ts`;

    if (!fs.existsSync(typesPath)) return;

    const project = new Project({
      skipAddingFilesFromTsConfig: true,
    });

    const sourceFile = project.addSourceFileAtPath(typesPath);

    // Check if file has AUTO-GENERATED marker
    const statements = sourceFile.getStatements();
    let hasAutoGenerated = false;
    let autoGenStartIndex = -1;
    let autoGenEndIndex = -1;

    for (let i = 0; i < statements.length; i++) {
      const stmt = statements[i];
      if (!stmt) continue;
      const text = stmt.getText();
      if (text.includes("AUTO-GENERATED by sveltekit-auto-openapi")) {
        hasAutoGenerated = true;
        autoGenStartIndex = i;
        // Find all auto-generated content
        for (let j = i; j < statements.length; j++) {
          const innerStmt = statements[j];
          if (
            innerStmt &&
            innerStmt.getText().includes("export type RequestEvent")
          ) {
            autoGenEndIndex = j + 1; // Include the export statements
            break;
          }
        }
        break;
      }
    }

    if (!hasAutoGenerated) return;

    // Remove all auto-generated code
    if (autoGenStartIndex >= 0 && autoGenEndIndex >= 0) {
      const toRemove = statements.slice(autoGenStartIndex, autoGenEndIndex + 1);
      toRemove.forEach((s) => s.remove());

      // Add back original exports
      sourceFile.addStatements([
        "export type RequestEvent = Kit.RequestEvent<RouteParams, RouteId>;",
        "export type RequestHandler = Kit.RequestHandler<RouteParams, RouteId>;",
      ]);

      await sourceFile.save();
    }
  } catch (error) {
    console.error(
      `[sveltekit-auto-openapi] Error restoring types for ${routePath}:`,
      error
    );
  }
}
