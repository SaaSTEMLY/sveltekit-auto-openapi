import type { Handle, RequestEvent } from "@sveltejs/kit";
import { json } from "@sveltejs/kit";
import { Validator } from "@cfworker/json-schema";

// Import the validation registry (virtual module generated by Vite plugin)
// This contains JSON Schemas (converted from Zod at build time)
import validationRegistry, {
  initPromise,
  type ValidationRegistry,
  type MethodValidationConfig,
  type ValidationSchemaConfig,
} from "virtual:sveltekit-auto-openapi/schema-validation-map";

// JSON Schema validator will be created per-schema as needed

// Initialize the registry on module load
let registryReady = false;
if (initPromise) {
  initPromise.then(() => {
    registryReady = true;
  });
}

// Helper: Validate data with JSON Schema
async function validateWithJsonSchema(
  data: any,
  config: ValidationSchemaConfig,
  context: string
): Promise<{ success: boolean; error?: any }> {
  // Skip validation if flag is set
  if (config.skipValidation) {
    return { success: true };
  }

  // Validate using @cfworker/json-schema
  const schemaValidator = new Validator(config.schema);
  const result = schemaValidator.validate(data);

  if (!result.valid) {
    const shouldShowError = config.showErrorMessage ?? (import.meta.env.DEV ? true : false);

    if (shouldShowError) {
      // Format errors from JSON Schema validator
      // @cfworker/json-schema returns errors with instanceLocation (JSON Pointer format)
      const formattedErrors = result.errors.map((err: any) => ({
        path: err.instanceLocation.replace(/^\//, '').replace(/\//g, '.') || 'root',
        message: err.error,
        keyword: err.keyword,
      }));

      return {
        success: false,
        error: {
          error: `${context} validation failed`,
          issues: formattedErrors,
        },
      };
    } else {
      // Generic error for production
      return {
        success: false,
        error: {
          error: context.includes('Response') ? 'Internal server error' : 'Invalid request data',
        },
      };
    }
  }

  return { success: true };
}

export interface SchemaValidationHookOptions {
  validateOutput?: boolean; // Enable response validation (recommended for dev only)
}

const SchemaValidationHook =
  (options?: SchemaValidationHookOptions): Handle =>
  async ({ event, resolve }) => {
    // Wait for registry initialization in dev mode
    if (!registryReady && initPromise) {
      await initPromise;
      registryReady = true;
    }

    const method = event.request.method;

    // Convert SvelteKit route format to OpenAPI format
    const openApiPath = routeIdToOpenApiPath(event.route.id);

    // Direct access to validation config from bundled registry
    // No filesystem access needed - schemas are bundled at build time
    const methodValidation = (validationRegistry as ValidationRegistry)[
      openApiPath
    ]?.[method];

    if (!methodValidation) {
      // No validation configured for this route/method
      return await resolve(event);
    }

    // ===== CHECK IF METHOD IS IMPLEMENTED =====
    if (methodValidation.isImplemented === false) {
      // Method has config but is not implemented
      return json(
        { error: "Not implemented" },
        { status: 501 }
      );
    }

    // ===== INPUT VALIDATION =====
    if (methodValidation.input) {
      const inputResult = await validateInput(event, methodValidation);
      if (!inputResult.success) {
        return inputResult.errorResponse;
      }
    }

    // Call route handler
    const response = await resolve(event);

    // ===== OUTPUT VALIDATION =====
    // Only validate output if explicitly enabled (recommended for dev only)
    if (options?.validateOutput && methodValidation.output) {
      const outputResult = await validateOutput(
        response,
        event,
        methodValidation
      );
      if (!outputResult.success) {
        return outputResult.errorResponse;
      }
    }

    return response;
  };

// Helper: Convert SvelteKit route ID to OpenAPI path format
function routeIdToOpenApiPath(routeId: string | null): string {
  if (!routeId) return "";

  return routeId
    .replace(/\[\[\.\.\.(.*?)\]\]/g, "{$1}") // [[...rest]] → {rest}
    .replace(/\[\.\.\.(.*?)\]/g, "{$1}") // [...rest] → {rest}
    .replace(/\[(.*?)=.*?\]/g, "{$1}") // [id=int] → {id}
    .replace(/\[(.*?)\]/g, "{$1}"); // [id] → {id}
}

// Helper: Validate request input
async function validateInput(
  event: RequestEvent,
  config: MethodValidationConfig
): Promise<{ success: true } | { success: false; errorResponse: Response }> {
  // Config is already loaded from the registry - no filesystem access needed
  if (!config.input) {
    return { success: true };
  }

  const inputConfig = config.input;

  // Validate request body
  if (inputConfig.body) {
    const contentType = event.request.headers.get("content-type");
    if (!contentType?.includes("application/json")) {
      // Skip validation for non-JSON requests
      return { success: true };
    }

    // Clone request to preserve original for route handler
    const clonedRequest = event.request.clone();

    let requestBody: unknown;
    try {
      requestBody = await clonedRequest.json();
    } catch (e) {
      return {
        success: false,
        errorResponse: json(
          { error: "Invalid JSON in request body" },
          { status: 400 }
        ),
      };
    }

    // Validate with JSON Schema
    const result = await validateWithJsonSchema(requestBody, inputConfig.body, 'Request body');

    if (!result.success) {
      return {
        success: false,
        errorResponse: json(result.error, { status: 400 }),
      };
    }
  }

  // Validate query parameters
  if (inputConfig.query) {
    const url = new URL(event.request.url);
    const queryParams: Record<string, string> = {};

    // Convert URLSearchParams to plain object
    url.searchParams.forEach((value, key) => {
      queryParams[key] = value;
    });

    const result = await validateWithJsonSchema(queryParams, inputConfig.query, 'Query parameters');

    if (!result.success) {
      return {
        success: false,
        errorResponse: json(result.error, { status: 400 }),
      };
    }
  }

  // Validate path parameters
  if (inputConfig.parameters) {
    const result = await validateWithJsonSchema(event.params, inputConfig.parameters, 'Path parameters');

    if (!result.success) {
      return {
        success: false,
        errorResponse: json(result.error, { status: 400 }),
      };
    }
  }

  // Validate headers
  if (inputConfig.headers) {
    const headers: Record<string, string> = {};

    // Convert Headers to plain object
    event.request.headers.forEach((value, key) => {
      headers[key] = value;
    });

    const result = await validateWithJsonSchema(headers, inputConfig.headers, 'Headers');

    if (!result.success) {
      return {
        success: false,
        errorResponse: json(result.error, { status: 400 }),
      };
    }
  }

  // Validate cookies
  if (inputConfig.cookies) {
    const cookies: Record<string, string> = {};

    // Parse cookies from event.cookies
    // SvelteKit provides cookies via event.cookies.getAll()
    const cookieHeader = event.request.headers.get("cookie");
    if (cookieHeader) {
      cookieHeader.split(";").forEach((cookie) => {
        const [name, ...valueParts] = cookie.trim().split("=");
        if (name) {
          cookies[name] = valueParts.join("=");
        }
      });
    }

    const result = await validateWithJsonSchema(cookies, inputConfig.cookies, 'Cookies');

    if (!result.success) {
      return {
        success: false,
        errorResponse: json(result.error, { status: 400 }),
      };
    }
  }

  return { success: true };
}

// Helper: Validate response output
async function validateOutput(
  response: Response,
  event: RequestEvent,
  config: MethodValidationConfig
): Promise<{ success: true } | { success: false; errorResponse: Response }> {
  // Config is already loaded from the registry - no filesystem access needed
  if (!config.output) {
    return { success: true };
  }

  const outputConfig = config.output;
  const statusCode = response.status.toString();

  // Find matching response schema (specific status code, wildcard, or default)
  let responseSchema = outputConfig[statusCode];

  if (!responseSchema) {
    // Try wildcard pattern (e.g., "2XX" for 200-299)
    const wildcardCode = `${statusCode[0]}XX`;
    responseSchema = outputConfig[wildcardCode];
  }

  if (!responseSchema) {
    // Try default
    responseSchema = outputConfig.default;
  }

  if (!responseSchema?.body) {
    return { success: true };
  }

  // Check content type
  const contentType = response.headers.get("content-type");
  if (!contentType?.includes("application/json")) {
    // Skip validation for non-JSON responses
    return { success: true };
  }

  // Clone response to read body
  const clonedResponse = response.clone();

  let responseBody: unknown;
  try {
    responseBody = await clonedResponse.json();
  } catch (e) {
    // Not JSON or empty, skip validation
    return { success: true };
  }

  // Validate response body
  if (responseSchema.body) {
    const result = await validateWithJsonSchema(responseBody, responseSchema.body, 'Response body');

    if (!result.success) {
      console.error("[Validation] Response body validation failed:", {
        route: event.route.id,
        method: event.request.method,
        error: result.error,
      });
      return {
        success: false,
        errorResponse: json(result.error, { status: 500 }),
      };
    }
  }

  // Validate response headers
  if (responseSchema.headers) {
    // Validate each header separately since they're stored as Record<string, ValidationSchemaConfig>
    const headers: Record<string, string> = {};
    response.headers.forEach((value, key) => {
      headers[key] = value;
    });

    for (const [headerName, headerConfig] of Object.entries(responseSchema.headers)) {
      const headerValue = headers[headerName.toLowerCase()]; // Headers are case-insensitive
      const result = await validateWithJsonSchema(
        headerValue,
        headerConfig,
        `Response header '${headerName}'`
      );

      if (!result.success) {
        console.error("[Validation] Response header validation failed:", {
          route: event.route.id,
          method: event.request.method,
          header: headerName,
          error: result.error,
        });
        return {
          success: false,
          errorResponse: json(result.error, { status: 500 }),
        };
      }
    }
  }

  // Validate response cookies (Set-Cookie headers)
  if (responseSchema.cookies) {
    const cookies: Record<string, string> = {};

    // Parse Set-Cookie headers
    const setCookieHeaders = response.headers.get("set-cookie");
    if (setCookieHeaders) {
      // Parse cookie name=value pairs from Set-Cookie header
      setCookieHeaders.split(",").forEach((cookieStr) => {
        const [nameValue] = cookieStr.trim().split(";");
        if (nameValue) {
          const [name, ...valueParts] = nameValue.split("=");
          if (name) {
            cookies[name.trim()] = valueParts.join("=").trim();
          }
        }
      });
    }

    const result = await validateWithJsonSchema(cookies, responseSchema.cookies, 'Response cookies');

    if (!result.success) {
      console.error("[Validation] Response cookies validation failed:", {
        route: event.route.id,
        method: event.request.method,
        error: result.error,
      });
      return {
        success: false,
        errorResponse: json(result.error, { status: 500 }),
      };
    }
  }

  return { success: true };
}

// Note: Error formatting is now handled directly in validateWithJsonSchema helper
// which uses the $showErrorMessage flag from the validation config

// Named export for better discoverability
export const createSchemaValidationHook = SchemaValidationHook;

// Default export
export default SchemaValidationHook;
