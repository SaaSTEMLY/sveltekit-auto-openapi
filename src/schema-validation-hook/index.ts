import type { Handle, RequestEvent } from "@sveltejs/kit";
import { json } from "@sveltejs/kit";
import type { ZodError } from "zod";

// Import the validation registry (virtual module generated by Vite plugin)
// This contains actual Zod schemas bundled at build time
import validationRegistry, {
  initPromise,
  type ValidationRegistry,
  type MethodValidationConfig,
} from "sveltekit-auto-openapi/schema-validation-map";

// Initialize the registry on module load
let registryReady = false;
if (initPromise) {
  initPromise.then(() => {
    registryReady = true;
  });
}

const SchemaValidationHook =
  (): Handle =>
  async ({ event, resolve }) => {
    // Wait for registry initialization in dev mode
    if (!registryReady && initPromise) {
      await initPromise;
      registryReady = true;
    }

    const method = event.request.method;

    // Convert SvelteKit route format to OpenAPI format
    const openApiPath = routeIdToOpenApiPath(event.route.id);

    // Direct access to validation config from bundled registry
    // No filesystem access needed - schemas are bundled at build time
    const methodValidation = (validationRegistry as ValidationRegistry)[
      openApiPath
    ]?.[method];

    if (!methodValidation) {
      // No validation configured for this route/method
      return await resolve(event);
    }

    // ===== INPUT VALIDATION =====
    if (methodValidation.input) {
      const inputResult = await validateInput(event, methodValidation);
      if (!inputResult.success) {
        return inputResult.errorResponse;
      }
    }

    // Call route handler
    const response = await resolve(event);

    // ===== OUTPUT VALIDATION =====
    if (methodValidation.output) {
      const outputResult = await validateOutput(
        response,
        event,
        methodValidation
      );
      if (!outputResult.success) {
        return outputResult.errorResponse;
      }
    }

    return response;
  };

// Helper: Convert SvelteKit route ID to OpenAPI path format
function routeIdToOpenApiPath(routeId: string | null): string {
  if (!routeId) return "";

  return routeId
    .replace(/\[\[\.\.\.(.*?)\]\]/g, "{$1}") // [[...rest]] → {rest}
    .replace(/\[\.\.\.(.*?)\]/g, "{$1}") // [...rest] → {rest}
    .replace(/\[(.*?)=.*?\]/g, "{$1}") // [id=int] → {id}
    .replace(/\[(.*?)\]/g, "{$1}"); // [id] → {id}
}

// Helper: Validate request input
async function validateInput(
  event: RequestEvent,
  config: MethodValidationConfig
): Promise<{ success: true } | { success: false; errorResponse: Response }> {
  // Config is already loaded from the registry - no filesystem access needed
  if (!config.input) {
    return { success: true };
  }

  const inputConfig = config.input;

  // Validate request body
  if (inputConfig.body) {
    const contentType = event.request.headers.get("content-type");
    if (!contentType?.includes("application/json")) {
      // Skip validation for non-JSON requests
      return { success: true };
    }

    // Clone request to preserve original for route handler
    const clonedRequest = event.request.clone();

    let requestBody: unknown;
    try {
      requestBody = await clonedRequest.json();
    } catch (e) {
      return {
        success: false,
        errorResponse: json(
          { error: "Invalid JSON in request body" },
          { status: 400 }
        ),
      };
    }

    // Validate with Zod
    const result = await inputConfig.body.safeParseAsync(requestBody);

    if (!result.success) {
      return {
        success: false,
        errorResponse: formatInputError(result.error, event),
      };
    }
  }

  // Validate query parameters
  if (inputConfig.query) {
    const url = new URL(event.request.url);
    const queryParams: Record<string, string> = {};

    // Convert URLSearchParams to plain object
    url.searchParams.forEach((value, key) => {
      queryParams[key] = value;
    });

    const result = await inputConfig.query.safeParseAsync(queryParams);

    if (!result.success) {
      return {
        success: false,
        errorResponse: formatInputError(result.error, event),
      };
    }
  }

  // Validate path parameters
  if (inputConfig.parameters) {
    const result = await inputConfig.parameters.safeParseAsync(event.params);

    if (!result.success) {
      return {
        success: false,
        errorResponse: formatInputError(result.error, event),
      };
    }
  }

  // Validate headers
  if (inputConfig.headers) {
    const headers: Record<string, string> = {};

    // Convert Headers to plain object
    event.request.headers.forEach((value, key) => {
      headers[key] = value;
    });

    const result = await inputConfig.headers.safeParseAsync(headers);

    if (!result.success) {
      return {
        success: false,
        errorResponse: formatInputError(result.error, event),
      };
    }
  }

  // Validate cookies
  if (inputConfig.cookies) {
    const cookies: Record<string, string> = {};

    // Parse cookies from event.cookies
    // SvelteKit provides cookies via event.cookies.getAll()
    const cookieHeader = event.request.headers.get("cookie");
    if (cookieHeader) {
      cookieHeader.split(";").forEach((cookie) => {
        const [name, ...valueParts] = cookie.trim().split("=");
        if (name) {
          cookies[name] = valueParts.join("=");
        }
      });
    }

    const result = await inputConfig.cookies.safeParseAsync(cookies);

    if (!result.success) {
      return {
        success: false,
        errorResponse: formatInputError(result.error, event),
      };
    }
  }

  return { success: true };
}

// Helper: Validate response output
async function validateOutput(
  response: Response,
  event: RequestEvent,
  config: MethodValidationConfig
): Promise<{ success: true } | { success: false; errorResponse: Response }> {
  // Config is already loaded from the registry - no filesystem access needed
  if (!config.output) {
    return { success: true };
  }

  const outputConfig = config.output;
  const statusCode = response.status.toString();

  // Find matching response schema (specific status code, wildcard, or default)
  let responseSchema = outputConfig[statusCode];

  if (!responseSchema) {
    // Try wildcard pattern (e.g., "2XX" for 200-299)
    const wildcardCode = `${statusCode[0]}XX`;
    responseSchema = outputConfig[wildcardCode];
  }

  if (!responseSchema) {
    // Try default
    responseSchema = outputConfig.default;
  }

  if (!responseSchema?.body) {
    return { success: true };
  }

  // Check content type
  const contentType = response.headers.get("content-type");
  if (!contentType?.includes("application/json")) {
    // Skip validation for non-JSON responses
    return { success: true };
  }

  // Clone response to read body
  const clonedResponse = response.clone();

  let responseBody: unknown;
  try {
    responseBody = await clonedResponse.json();
  } catch (e) {
    // Not JSON or empty, skip validation
    return { success: true };
  }

  // Validate response body
  if (responseSchema.body) {
    const result = await responseSchema.body.safeParseAsync(responseBody);

    if (!result.success) {
      return {
        success: false,
        errorResponse: formatOutputError(result.error, event),
      };
    }
  }

  // Validate response headers
  if (responseSchema.headers) {
    const headers: Record<string, string> = {};

    // Convert response Headers to plain object
    response.headers.forEach((value, key) => {
      headers[key] = value;
    });

    const result = await responseSchema.headers.safeParseAsync(headers);

    if (!result.success) {
      console.error("[Validation] Response headers validation failed:", {
        route: event.route.id,
        method: event.request.method,
        errors: result.error.issues,
      });
      return {
        success: false,
        errorResponse: formatOutputError(result.error, event),
      };
    }
  }

  // Validate response cookies (Set-Cookie headers)
  if (responseSchema.cookies) {
    const cookies: Record<string, string> = {};

    // Parse Set-Cookie headers
    const setCookieHeaders = response.headers.get("set-cookie");
    if (setCookieHeaders) {
      // Parse cookie name=value pairs from Set-Cookie header
      setCookieHeaders.split(",").forEach((cookieStr) => {
        const [nameValue] = cookieStr.trim().split(";");
        if (nameValue) {
          const [name, ...valueParts] = nameValue.split("=");
          if (name) {
            cookies[name.trim()] = valueParts.join("=").trim();
          }
        }
      });
    }

    const result = await responseSchema.cookies.safeParseAsync(cookies);

    if (!result.success) {
      console.error("[Validation] Response cookies validation failed:", {
        route: event.route.id,
        method: event.request.method,
        errors: result.error.issues,
      });
      return {
        success: false,
        errorResponse: formatOutputError(result.error, event),
      };
    }
  }

  return { success: true };
}

// Helper: Format input validation error
function formatInputError(zodError: ZodError, event: RequestEvent): Response {
  // Check if route config allows detailed errors
  const showDetails = shouldShowDetailedErrors(event);

  if (showDetails) {
    return json(
      {
        error: "Validation failed",
        issues: zodError.issues.map((e) => ({
          path: e.path.join("."),
          message: e.message,
          code: e.code,
        })),
      },
      { status: 400 }
    );
  }

  // Generic error for production
  return json({ error: "Invalid request data" }, { status: 400 });
}

// Helper: Format output validation error
function formatOutputError(zodError: ZodError, event: RequestEvent): Response {
  // Log detailed error for debugging
  console.error("[Validation] Response validation failed:", {
    route: event.route.id,
    method: event.request.method,
    errors: zodError.issues,
  });

  const showDetails = shouldShowDetailedErrors(event);

  if (showDetails) {
    return json(
      {
        error: "Response validation failed",
        issues: zodError.issues.map((e) => ({
          path: e.path.join("."),
          message: e.message,
          code: e.code,
        })),
      },
      { status: 500 }
    );
  }

  // Generic error for production
  return json({ error: "Internal server error" }, { status: 500 });
}

// Helper: Check if detailed errors should be shown (placeholder for future enhancement)
function shouldShowDetailedErrors(_event: RequestEvent): boolean {
  // MVP: Use environment detection
  // TODO: Check _config for exposeValidationErrors flag
  return import.meta.env.DEV;
}

export default SchemaValidationHook;
